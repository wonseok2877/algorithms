/* 11729. 하노이의 탑
한 번에 한 개의 원판만을 다른 탑으로 옮길 수 있다.
쌓아 놓은 원판은 항상 위의 것이 아래의 것보다 작아야 한다.
이 작업을 수행하는데 필요한 최소 이동 순서를 출력하는 프로그램을 작성하라.
원판의 개수 N (1 ≤ N ≤ 20)

 # 문제 재정의와 추상화
n짜리 탑에 대한 순환적인 과정을 캐치하고 재귀로 옮기는 문제.
그리고 이동순서를 어떻게 출력할지 묻는 문제.

# 문제 접근 과정
 n번째 기둥을 '주춧돌'로써 쌓기 바로 전까지, 하나의 예비 공간과 목표 공간은 비어있는 (n보다 작거나 같은 수가 없는 상태) 순간이 있어야 한다.
=> n-1 하노이탑을 하나의 예비공간에다 쌓아야 함.

 hanoi(1):
 1. n보다 작은 애들이 없으므로 안 치움
 2. 1을 주춧돌로써 목표 공간으로 옮기기
 3. 1은 가장 작은 값이므로 재귀호출 실행 없이 종료. (기저사례?)

 hanoi(2):
 1. n보다 작은 애들 치우기 : 다른 예비공간에다가 hanoi(1)
 2. 2를 주춧돌로써 목표공간으로 옮기기
 3. n보다 작은 애들을 위에 쌓기 : 목표공간, 즉 2 위에다가 hanoi(1)

 hanoi(n):
 1. n보다 작은 애들 치우기 : 다른 예비공간에다 hanoi(n-1)
 2. n을 주춧돌로써 목표공간으로 옮기기
 3. n보다 작은 애들을 n(주춧돌) 위에 쌓기 : 목표공간에다 hanoi(n-1)

 # 계획
 재귀함수를 어떻게 짤지, 어떤 자료구조를 쓸지 고민해보자.
 일단 자료구조로는 stack 3개를 쓴다. 예비 stack 2개와 목표 stack 1개. 두 예비 공간간의 구분이 필요
 c++ vector의 push_back, pop_back을 쓰면 되겠다.

 재귀함수로는 우선 저 공식으로 하되, 기저사례를 꼼꼼히 보자.
 전제 : n은 언제나 1~20 사이의 자연수이고 탑에 중복되는 값은 없다.
 기저사례 a : n==1일 경우, 목표공간으로 옮긴 뒤에 함수 종료

 hanoi(n, stack):
 1. n!=1일 경우, n보다 작은 애들 치우기
 1-1. 다른 예비공간이 뭔지 정하기
 1-2. hanoi(n-1, 다른 예비공간)
 2. n을 주춧돌로써 목표인 stack으로 옮기기 --- 여기서 stack은 목표공간이 아니다. 인자로 전달받은 공간.
 2-1. 기저사례 : n==1일 경우, 함수 종료.
 3. n보다 작은 애들을 n(주춧돌) 위에 쌓기 : 목표공간에다 hanoi(n-1)

 # 계획 검증
 ## 시간 복잡도
 이 하노이 재귀 함수는 O(2^N). 재귀 피보나치의 시간복잡도와 비슷한 것 같다.
 한 함수에서 재귀호출을 두번하니까.

 ## 공간 복잡도

 # 회고
 - 하노이를 미리 알고 있거나 시간복잡도 계산을 잘 해야 풀 수 있는 문제.
 - 감이 안 올 때는 역시 일단 작은 수부터 대입(삽질) -> 패턴을 직관적으로 파악 -> 공식 도출
 - 반은 성공했다. 하노이 타워 과정을 파악하고 그걸 재귀함수 조각으로 쪼개는것까지는 성공했다. 인자로 start, end를 넣는것까지도 같았고.
 - 그러나 하노이의 성질을 대충 파악해서, 쓸데없는 예외케이스들이나 자료구조를 쓰게 됐다.
 - 본질은 이동순서였다. 진짜 배열에다가 push, pop등 해서 옮기는게 아니라, 여기선 출력만 하면 됐음.
 - '하노이가 stack을 닮았는데...?'라는 생각에 매몰돼서 n과 stack을 어떻게 해야 할지에 시간을 너무 많이 썼다.

참조 https://study-all-night.tistory.com/6
 */

#include <bits/stdc++.h>
using namespace std;
int cnt = 0;

// hanoi : O(2^N) 재귀함수
void hanoi(int n, int start, int end){
    // 나머지 칸
    int bypass = 6-start-end;
    // 기저사례 : 1일 경우 재귀호출하지 않고 함수 종료.
    if(n == 1)
        printf("%d %d\n", start, end);
    else{
        // 1단계. 옆으로 치우기
        hanoi(n-1, start, bypass);
        // 2단계. 주춧돌로써 이동하는 순간을 출력.
        cnt ++;
        printf("%d %d\n", start, end);
        // 3단계. 주춧돌 위에 쌓기
        hanoi(n-1, bypass, end);
    }
}

int main(){
    ios_base :: sync_with_stdio(false);
    cin.tie(NULL); cout.tie(NULL);

    int n;
    cin >> n;

    // 이동횟수 = n^2 -1
    cout << (1 << n) -1 << endl;
    hanoi(n,1,3);
}
