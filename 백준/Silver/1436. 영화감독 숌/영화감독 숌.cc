/* 1436. 영화감독 숌
종말의 숫자란 어떤 수에 6이 적어도 3개이상 연속으로 들어가는 수를 말한다.
따라서, 숌은 첫 번째 영화의 제목은 세상의 종말 666, 두 번째 영화의 제목은 세상의 종말 1666 이렇게 이름을 지을 것이다.
일반화해서 생각하면, N번째 영화의 제목은 세상의 종말 (N번째로 작은 종말의 숫자) 와 같다.
숌이 만든 N번째 영화의 제목에 들어간 숫자를 출력하는 프로그램을 작성하시오.

 # 문제 재정의
숫자 6이 3개 이상 연속해서 나오는 count(번째)를 세면서 N과 같아지는 순간의 숫자를 출력하는 문제.
핵심 과정은 그 숫자가 6이 3개 이상 연속해서 나오는 '종말의 숫자'인지 아닌지를 확인하는 과정.
6이 3개 연속해서 나오는 경우를 구해야 한다.
브루트 포스. 다른 방법 없이 반복문으로 무식하게 푸는 방법밖에 없다.

 # 계획
 수의 범위는 최대 6669999 정도이다. N이 최대 10000이기 때문.
 그렇다면 7자릿수에서 나올 수 있는 경우의 수인 5가지에 대해 체크하면 된다.
 7~5자리, 6~4자리, 5~3자리, 4~2자리, 3~1자리.

 그렇게 위의 경우에 해당되면 count를 올리고, count == N 이 되는 순간에 숫자를 출력한다.

 string으로 바꾸는 방법도 있을거같다.
 # 계획 검증
 예외케이스를 살펴보자. 666이 들어있는데, % 혹은 / 중에 0이 나오지 않는 경우가 있을수있다. 1666이 그렇다.

 ## 시간 복잡도
 실행횟수는 대략 7,000,000 * (사칙연산 + 조건연산) < 1초

 ## 공간 복잡도

 # 회고
  - 과하게 무식했다(브루트포스라는 취지에는 적합했으려나). 7자리에 한정되지 않은 풀이를 찾을 수 있었다.
 - 숫자 num을 끝 세자리수만 남기고, 그걸 666으로 나눈 나머지를 구하고, 숫자를 10으로 계속 나눠갔으면 됐다.
 - e.g. 6660 -> 660 X -> 10으로 나눔 -> 666 O , 166611 -> 611 X -> /=10 -> 661 X -> /=10 -> 666 O
 */

#include <bits/stdc++.h>
using namespace std;


int main(){
    ios_base :: sync_with_stdio(0);
    cin.tie(0); cout.tie(0);

    int n, count = 0;
    cin >> n;

    // loop(N과 일치하는 count를 찾을때까지)
    for (int num=665; num<987654321; num++){
        //  7~5자리
        if ((num/10000)%667 == 666) count ++;
        //  6~4자리
        else if (((num%1000000)/1000)%667 == 666) count ++;
        //  5~3자리
        else if (((num%100000)/100)%667 == 666) count ++;
        //  4~2자리
        else if (((num%10000)/10)%667 == 666) count ++;
        //  3~1자리
        else if ((num%1000)%667 == 666) count ++;

        if (count == n) {
            cout << num;
            return 0;
        }
    }
}
